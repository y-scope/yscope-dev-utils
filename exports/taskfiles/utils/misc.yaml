version: "3"

set: ["u", "pipefail"]
shopt: ["globstar"]

tasks:
  replace-text:
    desc: "Replaces some text in a file using sed."
    internal: true
    requires:
      vars: ["FILE_PATH", "SED_EXP"]
    cmds:
      - |-
        # NOTE:
        # 1. We can't use `sed -i` since `-i` has different syntax on Linux and macOS
        # 2. We can't use `--regexp` instead of `-E` since `--regexp` is not supported on macOS
        src="{{.FILE_PATH}}"
        dst="{{.FILE_PATH}}.tmp"
        sed -E "{{.SED_EXP}}" "${src}" > "${dst}"
        mv "${dst}" "${src}"

  create-venv:
    desc: "Creates a Python venv using the given requirements file."
    internal: true
    label: "create-venv-{{.LABEL}}"
    requires:
      vars: ["LABEL", "OUTPUT_DIR", "REQUIREMENTS_FILE"]
    cmds:
      - "rm -rf '{{.OUTPUT_DIR}}'"
      - "python3 -m venv '{{.OUTPUT_DIR}}'"
      # Remove calls to `hash` from the venv activation script since Task uses `gosh` rather than
      # `bash`.
      # NOTE: Older versions of Python's venv would only call `hash` if they detected the running
      # shell was one that had the command, but that's not the case in newer versions.
      - task: "replace-text"
        vars:
          FILE_PATH: "{{.OUTPUT_DIR}}/bin/activate"
          SED_EXP: >-
            s/^([[:space:]]*)hash[[:space:]]+.*/\1true/g
      - |-
        . "{{.OUTPUT_DIR}}/bin/activate"
        pip3 install --upgrade pip
        pip3 install --upgrade -r "{{.REQUIREMENTS_FILE}}"

  reset-dir:
    desc: "Clears the directory at the given path without removing the directory itself."
    internal: true
    label: "{{.TASK}}:{{.DIR_PATH}}"
    requires:
      vars: ["DIR_PATH"]
    run: "when_changed"
    preconditions:
      # This task runs once per unique directory path, which is fingerprinted by the task label. To
      # avoid possible label collisions, we avoid using relative paths.
      - sh: >-
          case "{{.DIR_PATH}}" in
            /*) exit 0;;
            *) exit 1;;
          esac
        msg: "DIR_PATH `{{.DIR_PATH}}` is not absolute."
    cmds:
      - |-
        mkdir -p "{{.DIR_PATH}}"
        find "{{.DIR_PATH}}" \! -path "{{.DIR_PATH}}" -prune \
          -exec rm -rf -- {} +

  reset-file:
    desc: "Removes the file at the given path and makes sure its parent directory exists."
    internal: true
    label: "{{.TASK}}:{{.FILE_PATH}}"
    vars:
      PARENT_DIR: "{{ dir .FILE_PATH }}"
    requires:
      vars: ["FILE_PATH"]
    run: "when_changed"
    preconditions:
      # This task runs once per unique file path, which is fingerprinted by the task label. To avoid
      # possible label collisions, we avoid using relative paths.
      - sh: >-
          case "{{.FILE_PATH}}" in
            /*) exit 0;;
            *) exit 1;;
          esac
        msg: "FILE_PATH `{{.FILE_PATH}}` is not absolute."
    cmds:
      - "rm -f '{{.FILE_PATH}}'"
      - "mkdir -p '{{.PARENT_DIR}}'"
