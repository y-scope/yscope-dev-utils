version: "3"

set: ["u", "pipefail"]
shopt: ["globstar"]

# The checksum tasks are a robust way for a task to decided whether or not it should run.
#
# For many tasks it is not feasible to list out all files in `sources` and `generates`. These tasks
# provide a way to `compute` a checksum for the contents of directories/files and `validate` whether
# the contents still match the checksum in later runs.
#
# When creating a checksum a task should:
#
# a. Call the `compute` task at the end to create the checksum file.
# b. Call `validate` in `deps` to verify the checksum file matches the current contents.
#   - `validate` will delete the checksum file if there is no match.
# c. Add the checksum file to `generates`. This ensures the task runs if:
#   - The task has not run before.
#   - `validate` deleted the checksum file as the contents did not match.
#
# When multiple tasks mutate the same contents, each task updates the checksum file and also tracks
# whether it has run or not by creating a sentinel file.
#
# a. Before calling `compute`, create a sentinel file with a name unique to the task.
# b. Add the sentinel file to `generates`. This ensures the task runs if:
#   - The checksum file exists and matches the contents, but this task has not been run.
#
# Additional guidelines:
#
# - When creating a directory that will be included in a checksum, always delete any existing
# contents first.
#   - This ensures that if the contents diverge from the checksum file, the task is re-run with no
#   stale data.
# - If task, A, implicitly depends on task, B, but A does not call `B` in `deps`, it is possible
# for a user to run A without having run B. A can ensure it fails gracefully by calling `validate`
# on B's checksum with `FAIL_ON_ERROR: "true"`.

tasks:
  # Compute the checksum of the given path include/exclude patterns, saving the result to
  # `CHECKSUM_FILE`. The calling task can set `IGNORE_ERROR` to "true" if they wish to continue if
  # checksum computation fails.
  #
  # @param {string} CHECKSUM_FILE
  # @param {string[]} INCLUDE_PATTERNS Path wildcard patterns to compute the checksum for.
  # @param {string[]} [EXCLUDE_PATTERNS=[]] Path wildcard patterns, relative to any
  # `INCLUDE_PATTERNS`, to exclude from the checksum.
  # @param {string} [IGNORE_ERROR="false"] If set to "true", the task will not fail on error.
  compute:
    internal: true
    label: "{{.TASK}}-{{.CHECKSUM_FILE}}"
    silent: true
    vars:
      EXCLUDE_PATTERNS:
        ref: "default (list) .EXCLUDE_PATTERNS"
      IGNORE_ERROR: "{{if eq \"true\" .IGNORE_ERROR}}true{{else}}false{{end}}"

      ARCHIVER: "{{if eq OS \"darwin\"}}gtar{{else}}tar{{end}}"
      TMP_ERR_LOG: "{{.CHECKSUM_FILE}}.log.tmp"
    requires:
      vars:
        - "CHECKSUM_FILE"
        - "INCLUDE_PATTERNS"
    cmds:
      - "mkdir -p '{{ dir .CHECKSUM_FILE }}'"
      # We explicitly set `--no-anchored` and `--wildcards` to make the inclusion behaviour match
      # the default exclusion behaviour.
      #
      # We can quote the exclude patterns for `tar` because the patterns themselves are passed to
      # `tar` as arguments and evaluated by `tar` during execution. However, for `tar --create`, the
      # input patterns cannot be quoted since they're evaluated by the shell and the results are
      # passed to `tar` as arguments. If the input patterns are passed to `tar` with quotes, the
      # pattern won't be evaluated and will instead be treated literally.
      - defer: "rm -f '{{.TMP_ERR_LOG}}'"
      - |-
        if ! \
          {{.ARCHIVER}} \
          --create \
          --file - \
          --group 0 \
          --mtime "UTC 1970-01-01" \
          --numeric-owner \
          --owner 0 \
          --sort name \
          --no-anchored \
          --wildcards \
          {{- range .EXCLUDE_PATTERNS}}
          --exclude="{{.}}" \
          {{- end}}
          {{- range .INCLUDE_PATTERNS}}
          {{.}} \
          {{- end}}
          2>> "{{.TMP_ERR_LOG}}" \
            | md5sum > "{{.CHECKSUM_FILE}}" \
        ; then
          rm -f "{{.CHECKSUM_FILE}}"
          {{- if eq "false" .IGNORE_ERROR}}
            printf "[{{.TASK}} error] failed with:\n%s\n" "$(cat '{{.TMP_ERR_LOG}}')"
            exit 1
          {{- end}}
        fi

  # Validates that the checksum computed from the given include/exclude path patterns matches the
  # reference checksum stored in the given file. If validation fails, the checksum file is deleted,
  # but the task succeeds so dependent tasks that list the checksum file under `generates` will
  # rerun automatically. The calling task can set `FAIL_ON_ERROR` to "true" to make this task fail
  # when the validation is expected to succeed.
  #
  # @param {string} CHECKSUM_FILE
  # @param {string[]} INCLUDE_PATTERNS Path wildcard patterns to validate the checksum for.
  # @param {string[]} [EXCLUDE_PATTERNS=[]] Path wildcard patterns, relative to any
  # `INCLUDE_PATTERNS`, to exclude from the checksum.
  # @param {string} [FAIL_ON_ERROR="false"] If set to "true", the task fails when checksums
  # mismatch.
  validate:
    internal: true
    label: "{{.TASK}}-{{.CHECKSUM_FILE}}"
    silent: true
    vars:
      FAIL_ON_ERROR: "{{if eq \"true\" .FAIL_ON_ERROR}}true{{else}}false{{end}}"
      TMP_CHECKSUM_FILE: "{{.CHECKSUM_FILE}}.tmp"
      TMP_ERR_LOG: "{{.CHECKSUM_FILE}}.log.tmp"
    requires:
      vars:
        - "CHECKSUM_FILE"
        - "INCLUDE_PATTERNS"
    cmds:
      - task: "compute"
        vars:
          CHECKSUM_FILE: "{{.TMP_CHECKSUM_FILE}}"
          INCLUDE_PATTERNS:
            ref: ".INCLUDE_PATTERNS"
          EXCLUDE_PATTERNS:
            ref: ".EXCLUDE_PATTERNS"
          IGNORE_ERROR: "true"
      - defer: |-
          rm -f "{{.TMP_CHECKSUM_FILE}}"
          rm -f "{{.TMP_ERR_LOG}}"
      - |-
        (
          {{- range .INCLUDE_PATTERNS}}
            for path in {{.}}; do
              test -e "${path}" \
                || (
                  echo "Include path does not exist: ${path}" >> "{{$.TMP_ERR_LOG}}"
                  exit 1
                )
            done && \
          {{- end}}
            (
              cmp -s "{{.TMP_CHECKSUM_FILE}}" "{{.CHECKSUM_FILE}}" \
              || (
                echo "cmp failed for '{{.TMP_CHECKSUM_FILE}}' '{{.CHECKSUM_FILE}}'" \
                  >> "{{.TMP_ERR_LOG}}"
                exit 1
                )
            )
        ) \
          || (
            {{- if eq "true" .FAIL_ON_ERROR}}
              printf "[{{.TASK}} error] failed with:\n%s\n" "$(cat '{{.TMP_ERR_LOG}}')"
              exit 1
            {{- end}}
            rm -f "{{.CHECKSUM_FILE}}"
          )
